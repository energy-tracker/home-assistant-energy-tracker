#!/usr/bin/env python3
"""Sync ruff configuration from Home Assistant Core.

This script fetches the ruff configuration from Home Assistant Core's pyproject.toml,
transforms paths for custom_components structure, applies local overrides,
and generates a ruff.generated.toml file.

It also syncs the Python version requirement.
"""

import re
import urllib.request
from pathlib import Path

CORE_PYPROJECT_URL = (
    "https://raw.githubusercontent.com/home-assistant/core/dev/pyproject.toml"
)

# Local overrides - add rules to ignore or paths to adjust
LOCAL_OVERRIDES = {
    # Additional rules to ignore for custom_components
    "additional_ignores": [],
    # Path replacements
    "path_replacements": [
        ("homeassistant/", "custom_components/energy_tracker/"),
        ("homeassistant", "custom_components"),
        ("tests/components/", "tests/"),
    ],
    # Sections to skip entirely
    "skip_sections": [
        "tool.ruff.lint.flake8-import-conventions.extend-aliases",
    ],
    # Additional per-file-ignores
    "additional_per_file_ignores": {
        "custom_components/energy_tracker/__init__.py": ["F401"],
    },
}


def fetch_core_config() -> str:
    """Fetch pyproject.toml from Home Assistant Core."""
    print(f"Fetching {CORE_PYPROJECT_URL}...")
    with urllib.request.urlopen(CORE_PYPROJECT_URL) as response:
        return response.read().decode("utf-8")


def extract_python_version(content: str) -> str | None:
    """Extract minimum Python version from requires-python.

    Example: 'requires-python = ">=3.13.2"' -> '3.13'
    """
    match = re.search(r'requires-python\s*=\s*">=(\d+\.\d+)', content)
    if match:
        return match.group(1)
    return None


def extract_ruff_sections(content: str) -> dict[str, list[str]]:
    """Extract all [tool.ruff*] sections from pyproject.toml."""
    sections: dict[str, list[str]] = {}
    current_section = None
    current_lines: list[str] = []

    for line in content.split("\n"):
        # Check for new section
        if line.startswith("["):
            # Save previous section
            if current_section and current_section.startswith("tool.ruff"):
                sections[current_section] = current_lines

            # Extract section name
            match = re.match(r"\[([^\]]+)\]", line)
            if match:
                current_section = match.group(1)
                current_lines = []
            else:
                current_section = None
                current_lines = []
        elif current_section:
            current_lines.append(line)

    # Don't forget the last section
    if current_section and current_section.startswith("tool.ruff"):
        sections[current_section] = current_lines

    return sections


def transform_paths(lines: list[str]) -> list[str]:
    """Transform Home Assistant paths to custom_components paths."""
    transformed = []
    for line in lines:
        new_line = line
        for old, new in LOCAL_OVERRIDES["path_replacements"]:
            new_line = new_line.replace(f'"{old}', f'"{new}')
        transformed.append(new_line)
    return transformed


def should_skip_section(section_name: str) -> bool:
    """Check if a section should be skipped."""
    for skip in LOCAL_OVERRIDES["skip_sections"]:
        if section_name == skip or section_name.startswith(skip):
            return True
    return False


def generate_ruff_toml(sections: dict[str, list[str]]) -> str:
    """Generate the ruff.core.toml content."""
    output_lines = [
        "# AUTO-GENERATED FILE - DO NOT EDIT MANUALLY",
        "# Generated by scripts/sync_ruff_config.py from Home Assistant Core",
        "# Run 'make sync-ruff' to update",
        "#",
        "# For local overrides, edit ruff.base.toml instead.",
        "",
    ]

    for section_name, lines in sorted(sections.items()):
        if should_skip_section(section_name):
            output_lines.append(f"# Skipped: [{section_name}]")
            output_lines.append("")
            continue

        # Convert tool.ruff.* to just the ruff part for ruff.toml
        # [tool.ruff] -> top level
        # [tool.ruff.lint] -> [lint]
        # [tool.ruff.lint.per-file-ignores] -> [lint.per-file-ignores]
        if section_name == "tool.ruff":
            output_lines.append("# Base ruff configuration")
        else:
            ruff_section = section_name.replace("tool.ruff.", "")
            output_lines.append(f"[{ruff_section}]")

        # Transform and add lines
        transformed_lines = transform_paths(lines)
        for line in transformed_lines:
            # Skip empty lines at the end
            if (
                line.strip()
                or transformed_lines.index(line) < len(transformed_lines) - 1
            ):
                output_lines.append(line)

        output_lines.append("")

    return "\n".join(output_lines)


def add_local_overrides(content: str) -> str:
    """Add local overrides to the generated content."""
    lines = content.split("\n")

    # Add additional per-file-ignores
    if LOCAL_OVERRIDES["additional_per_file_ignores"]:
        # Find the per-file-ignores section or add it
        insert_idx = None
        for i, line in enumerate(lines):
            if line.strip() == "[lint.per-file-ignores]":
                insert_idx = i + 1
                break

        if insert_idx:
            for path, ignores in LOCAL_OVERRIDES["additional_per_file_ignores"].items():
                ignore_str = ", ".join(f'"{i}"' for i in ignores)
                lines.insert(insert_idx, f'"{path}" = [{ignore_str}]')
                insert_idx += 1

    return "\n".join(lines)


def update_python_version_in_files(python_version: str) -> None:
    """Update Python version in ruff.base.toml, pyproject.toml, and CI workflow."""
    project_root = Path(__file__).parent.parent
    py_version = f"py{python_version.replace('.', '')}"  # 3.13 -> py313

    # Update ruff.base.toml
    ruff_base_path = project_root / "ruff.base.toml"
    if ruff_base_path.exists():
        content = ruff_base_path.read_text()
        new_content = re.sub(
            r'target-version\s*=\s*"py\d+"',
            f'target-version = "{py_version}"',
            content,
        )
        if new_content != content:
            ruff_base_path.write_text(new_content)
            print(f'Updated ruff.base.toml: target-version = "{py_version}"')

    # Update pyproject.toml
    pyproject_path = project_root / "pyproject.toml"
    if pyproject_path.exists():
        content = pyproject_path.read_text()
        new_content = re.sub(
            r'python_version\s*=\s*"\d+\.\d+"',
            f'python_version = "{python_version}"',
            content,
        )
        if new_content != content:
            pyproject_path.write_text(new_content)
            print(f'Updated pyproject.toml: python_version = "{python_version}"')

    # Update CI workflow
    ci_path = project_root / ".github" / "workflows" / "ci.yml"
    if ci_path.exists():
        content = ci_path.read_text()
        new_content = re.sub(
            r'python-version:\s*"\d+\.\d+"',
            f'python-version: "{python_version}"',
            content,
        )
        if new_content != content:
            ci_path.write_text(new_content)
            print(f'Updated .github/workflows/ci.yml: python-version: "{python_version}"')


def main() -> None:
    """Main entry point."""
    # Fetch core config
    core_content = fetch_core_config()

    # Extract Python version
    python_version = extract_python_version(core_content)
    if python_version:
        print(f"Found Python version requirement: >= {python_version}")
        update_python_version_in_files(python_version)
    else:
        print("Warning: Could not extract Python version from Core")

    # Extract ruff sections
    sections = extract_ruff_sections(core_content)
    print(f"Found {len(sections)} ruff sections:")
    for name in sorted(sections.keys()):
        print(f"  - {name}")

    # Generate ruff.toml
    ruff_content = generate_ruff_toml(sections)

    # Add local overrides
    ruff_content = add_local_overrides(ruff_content)

    # Write output
    output_path = Path(__file__).parent.parent / "ruff.core.toml"

    # Remove write protection if file exists (from previous sync)
    if output_path.exists():
        output_path.chmod(0o644)

    output_path.write_text(ruff_content)

    # Make file read-only to prevent accidental edits
    output_path.chmod(0o444)
    print(f"\nGenerated: {output_path} (read-only)")

    # Also create/update ruff.base.toml that extends from core
    base_ruff_path = Path(__file__).parent.parent / "ruff.base.toml"
    if not base_ruff_path.exists():
        base_ruff_content = """\
# Ruff configuration for energy-tracker custom component
# This file extends ruff.core.toml (synced from HA Core)
# Add local customizations here

extend = "ruff.core.toml"

# Override target Python version
target-version = "py311"

# Override source paths
src = ["custom_components", "tests"]

[lint]
# Additional rules to ignore locally
extend-ignore = []

# Additional rules to select locally  
extend-select = []

[lint.per-file-ignores]
# Tests may access private members for verification
"tests/**" = ["SLF001"]
"""
        base_ruff_path.write_text(base_ruff_content)
        print(f"Created: {base_ruff_path}")
    else:
        print(f"Existing: {base_ruff_path} (not modified)")

    print("\nDone! Review the changes and commit the files.")


if __name__ == "__main__":
    main()
